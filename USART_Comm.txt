#include <avr/io.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <util/delay.h>
#include <stdint.h>
#include <avr/interrupt.h>

#define F_CPU 8000000  //8MHz

#define FOSC 8000000                       // Clock Speed
#define BAUD 9600
#define MYUBRR FOSC/16/BAUD -1

volatile char ReceivedChar;
volatile char rx_byte;


void USART_Init(){
	/*Set baud rate */
	UBRRH = (MYUBRR >> 8);
	UBRRL = MYUBRR;

	UCSRB |= (1 << RXEN) | (1 << TXEN);      // Enable receiver and transmitter
	UCSRB |= (1 << RXCIE);                   // Enable the receiver interrupt
	// Enable transmitter interrupt
	UCSRC |= (1 << URSEL) |(1 << UCSZ1) | (1 << UCSZ0);    // Set frame: 8data, 1 stp

}

void USART_Transmit(unsigned char data) {
	while ( !( UCSRA & (1<<UDRE)) ); // Czekaj na opró¿nienie budora transmicji
	UDR = data; // W³ó¿ dane do UDR, wyœlij dane
}

unsigned char USART_Receive () {
	 while ( !(UCSRA & (1 << RXC))); // data received
	 return UDR;	// odbierz dane z bufora
}



int main() {

	DDRD = 0b11111111;
	DDRB = 0b11111111;
	DDRC = 0b00000000;
	ADMUX = 0b01000000;
	ADCSRA = 0b10000111;

	TCCR1B |= (1<<WGM12); //w³¹czenie trybu CTC
	TCCR1B |= (1<<CS10) | (1<<CS11); //ustawienie preskalera na 64
	TCCR1A |= (1<<COM1A0);
	OCR1A = 25000; //wartoœæ do której zlicza licznik

	sei();
	// Main program loop
	while (1)
	{
		// Start an ADC conversion by setting ADSC bit (bit 6)
		ADCSRA = ADCSRA | (1 << ADSC);
		// Wait until the ADSC bit has been cleared
		while(ADCSRA & (1 << ADSC));

		OCR1A = 12500 - (10*ADC);


		rx_byte = USART_Receive();			// get the byte
		switch (rx_byte) {
			case 'a':
				PORTB = PORTB | (1 << PB4);
			break;

			case 'b':
				PORTB = PORTB & ~(1 << PB4);
			break;
		}
	}
}



ISR (USART_RXC_vect)
{
 //   ReceivedChar = UDR;                     // Read data from the RX buffer
 //   UDR = ReceivedChar;                     // Write the data to the TX buffer
}

ISR (USART_TXC_vect)
{
}
